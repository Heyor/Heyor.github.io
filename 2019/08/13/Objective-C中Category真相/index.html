<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Objective-C 中 Category 真相"><meta name="keywords" content="iOS"><meta name="author" content="范小忧"><meta name="copyright" content="范小忧"><title>Objective-C 中 Category 真相 | 范小忧的博客</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#前言"><span class="toc-number">1.</span> <span class="toc-text">前言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是分类（Category）"><span class="toc-number">2.</span> <span class="toc-text">什么是分类（Category）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#如何给已有的类添加一个分类"><span class="toc-number">2.1.</span> <span class="toc-text">如何给已有的类添加一个分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-和-Extension-的区别"><span class="toc-number">3.</span> <span class="toc-text">Category 和 Extension 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Category-真正的面目"><span class="toc-number">4.</span> <span class="toc-text">Category 真正的面目</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#未完待续…"><span class="toc-number">5.</span> <span class="toc-text">未完待续…</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">范小忧</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(ture)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">范小忧的博客</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">Objective-C 中 Category 真相</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-13</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际开发过程中，随着 App 版本的迭代，我的业务逻辑越来越复杂；原先我们设计和开发的类不能满足日常功能，需要添加新的功能。因此，我们需要对原有的类进行扩展。一般来说，继承和组合都是不错的选择；但在 Objective-C 2.0 中，又为我们提供了 Category 这一语言特征，让我们可以动态的为已存在的类添加新行为。那么，今天我们就来详细的了解下 Category 的使用和原理。</p>
<ul>
<li>什么是 Category，如何创建？</li>
<li>Category 和 Extension 的区别</li>
<li>Category 真正的面目</li>
<li>Category 是如何为已有类添加新功能的</li>
<li>Category 和 +(void)load 方法的关系</li>
<li>Category 和方法覆盖</li>
<li>Category 和关联对象</li>
</ul>
<a id="more"></a>

<h2 id="什么是分类（Category）"><a href="#什么是分类（Category）" class="headerlink" title="什么是分类（Category）"></a>什么是分类（Category）</h2><p>Category 是 Objective-C 2.0之后添加的语言特性，主要作用是为已有的类添加新方法。除此之外，Apple 还推荐了 Category 的另外两个使用场景：</p>
<ul>
<li><p>为类瘦身，把类的实现分别写在不同的文件中；</p>
<ol>
<li>减少单个文件的体积</li>
<li>可以把相同功能代码整合到同一个分类中</li>
<li>多人通过分类共同完成一个类，将降低耦合度</li>
<li>可以按需加载想要的 category</li>
</ol>
</li>
<li><p>声明私有方法。</p>
</li>
</ul>
<p>不过除了 Apple 推荐的使用场景，广大开发者脑洞大开，还衍生出了 Category 的其他几个使用场景：</p>
<ul>
<li>模拟多继承</li>
<li>把 Framework 的私有方法公开</li>
</ul>
<h3 id="如何给已有的类添加一个分类"><a href="#如何给已有的类添加一个分类" class="headerlink" title="如何给已有的类添加一个分类"></a>如何给已有的类添加一个分类</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassName</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)lastNameFirstNameString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassName</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)lastNameFirstNameString &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@, %@"</span>, <span class="keyword">self</span>.lastName, <span class="keyword">self</span>.firstName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h2 id="Category-和-Extension-的区别"><a href="#Category-和-Extension-的区别" class="headerlink" title="Category 和 Extension 的区别"></a>Category 和 Extension 的区别</h2><p>Extension 看起来很像一个匿名的 Category，但是 Extension和有名字的 Category 几乎完全是两个东西。下面我来分析下二者之间的区别：</p>
<p>Extension 编译期特征；在编译的过程中，与头文件中 @interface 和实现文件中 @implementation 一起组成了完整的类。Extension 会随着类的生成而生成，消亡而消亡。一般来说，我们通常使用 Extension 来隐藏私有的属性和方法；但是我们永远无法给系统的类添加 Extension。</p>
<p>Category 运行时特征；因此我们无法使用 Category 为已有类添加实例变量。（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p>
<h2 id="Category-真正的面目"><a href="#Category-真正的面目" class="headerlink" title="Category 真正的面目"></a>Category 真正的面目</h2><p>通过上述说明，我们知道了 Category 是运行时特性；所以，我看来运行时我们写的分类最终到底变成了什么？下面我们编写一个分类，并使用 clang 的命令去看看 Category 到底会变成什么？</p>
<p>首先，我先编写了 Person 类，并为 Person 类添加了 Addition 分类；在分类中具有属性 name 和方法 - (void)printName。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Addition</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span> ) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)loadNew;</span><br><span class="line">- (<span class="keyword">void</span>)printName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Addition</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"name"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)loadNew &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="string">@"Addition"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>之后，我使用<code>clang++ -rewrite-objc Person.m</code>将对代码进行了编译，等到了 cpp 文件；在 cpp 文件中我找到了下面几段代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[3];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Addition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    &#123;&#123;(struct objc_selector *)<span class="string">"setName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_Person_Addition_setName_&#125;,</span><br><span class="line">    &#123;(struct objc_selector *)<span class="string">"name"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_Person_Addition_name&#125;,</span><br><span class="line">    &#123;(struct objc_selector *)<span class="string">"printName"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_Person_Addition_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Addition</code>这个名称，我们很自然的知道了这里就是我们分类实例方法存放的位置。下面我们继续往下看。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Addition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;(struct objc_selector *)<span class="string">"loadNew"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_C_Person_Addition_loadNew&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 <code>_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Addition</code>这个名称，我们也很自然的知道了这里就是我们分类类方法存放的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Person_$_Addition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过 <code>_OBJC_$_PROP_LIST_Person_$_Addition</code>这个名称，我们也很自然的知道了这里就是我们分类属性方法存放的位置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Person_</span>$_<span class="title">Addition</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = &#123;</span></span><br><span class="line">    <span class="string">"Person"</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Person,</span></span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Addition,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Addition,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Person_$_Addition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Person_$_Addition(<span class="keyword">void</span> ) &#123;</span><br><span class="line">    _OBJC_$_CATEGORY_Person_$_Addition.cls = &amp;OBJC_CLASS_$_Person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看到这个，我们就应该忽然明白了我们的分类是如何创建的。这里创建了我们需要的分类并将实例方法列表、类方法列表、属性列表等绑定到了分类上；同时，也将分类和类进行了绑定。通过上述代码，我们知道了分类最终就是<code>category_t</code>结构体。下面我们来看看这个结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>1)、类的名字（name）</li>
<li>2)、类（cls）</li>
<li>3)、category中所有给类添加的实例方法的列表（instanceMethods）</li>
<li>4)、category中所有添加的类方法的列表（classMethods）</li>
<li>5)、category实现的所有协议的列表（protocols）</li>
<li>6)、category中添加的所有属性（instanceProperties）</li>
</ul>
<h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2></div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">范小忧</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://heyor.github.io/2019/08/13/Objective-C中Category真相/">https://heyor.github.io/2019/08/13/Objective-C中Category真相/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://heyor.github.io">范小忧的博客</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/iOS/">iOS</a></div><nav id="pagination"><div class="prev-post pull-left"><a href="/2019/08/20/Dart基础/"><i class="fa fa-chevron-left">  </i><span>Dart 基础</span></a></div><div class="next-post pull-right"><a href="/2019/08/07/iOS内存管理机制/"><span>iOS 内存管理机制</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(ture)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By 范小忧</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>