<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta name="description" content="Dart 中的类"><meta name="keywords" content="Dart,Flutter"><meta name="author" content="范小忧"><meta name="copyright" content="范小忧"><title>Dart 中的类 | 范小忧</title><link rel="shortcut icon" href="/melody-favicon.ico"><link rel="stylesheet" href="/css/index.css?version=1.6.1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css?version=1.6.1"><link rel="dns-prefetch" href="https://cdn.staticfile.org"><link rel="dns-prefetch" href="https://cdn.bootcss.com"><link rel="dns-prefetch" href="https://creativecommons.org"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  }
} </script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div id="sidebar"><div class="toggle-sidebar-info text-center"><span data-toggle="切换文章详情">切换站点概览</span><hr></div><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#如何定义和使用类"><span class="toc-number">1.</span> <span class="toc-text">如何定义和使用类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实例变量（instance-variable）"><span class="toc-number">2.</span> <span class="toc-text">实例变量（instance variable）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#构造函数"><span class="toc-number">3.</span> <span class="toc-text">构造函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#默认构造函数"><span class="toc-number">3.1.</span> <span class="toc-text">默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自定义默认构造函数"><span class="toc-number">3.2.</span> <span class="toc-text">自定义默认构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命名构造函数"><span class="toc-number">3.3.</span> <span class="toc-text">命名构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的调用过程"><span class="toc-number">3.4.</span> <span class="toc-text">构造函数的调用过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重定向构造函数"><span class="toc-number">3.5.</span> <span class="toc-text">重定向构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常量构造函数"><span class="toc-number">3.6.</span> <span class="toc-text">常量构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法构造函数"><span class="toc-number">3.7.</span> <span class="toc-text">工厂方法构造函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性"><span class="toc-number">4.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数"><span class="toc-number">5.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类变量和函数"><span class="toc-number">6.</span> <span class="toc-text">类变量和函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#创建一个子类"><span class="toc-number">7.</span> <span class="toc-text">创建一个子类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#隐式接口"><span class="toc-number">8.</span> <span class="toc-text">隐式接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#抽象函数"><span class="toc-number">9.</span> <span class="toc-text">抽象函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#枚举类型"><span class="toc-number">10.</span> <span class="toc-text">枚举类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#可调用的类"><span class="toc-number">11.</span> <span class="toc-text">可调用的类</span></a></li></ol></div></div><div class="author-info hide"><div class="author-info__avatar text-center"><img src="/img/avatar.png"></div><div class="author-info__name text-center">范小忧</div><div class="author-info__description text-center"></div><hr><div class="author-info-articles"><a class="author-info-articles__archives article-meta" href="/archives"><span class="pull-left">文章</span><span class="pull-right">6</span></a><a class="author-info-articles__tags article-meta" href="/tags"><span class="pull-left">标签</span><span class="pull-right">3</span></a></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(http://i0.hdslb.com/bfs/article/3b46e7336296964c01560257a5c561ae40f0e861.jpg)"><div id="page-header"><span class="pull-left"> <a id="site-name" href="/">范小忧</a></span><i class="fa fa-bars toggle-menu pull-right" aria-hidden="true"></i><span class="pull-right menus"><a class="site-page" href="/">首页</a><a class="site-page" href="/archives">归档</a><a class="site-page" href="/tags">标签</a><a class="site-page" href="/categories">分类</a></span></div><div id="post-info"><div id="post-title">Dart 中的类</div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 2019-08-21</time></div></div></div><div class="layout" id="content-inner"><article id="post"><div class="article-container" id="post-content"><p>Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有类都来自Object。接下来，我们以一个具体的案例看看Dart 是如何定义和使用类。</p>
<h2 id="如何定义和使用类"><a href="#如何定义和使用类" class="headerlink" title="如何定义和使用类"></a>如何定义和使用类</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> factor = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 语法糖，等同于在函数体内：this.x = x;this.y = y;</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">void</span> printInfo() =&gt; <span class="built_in">print</span>(<span class="string">'(<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> printZValue() =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$factor</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">200</span>); <span class="comment">// new 关键字可以省略</span></span><br><span class="line">p.printInfo();  <span class="comment">// 输出 (100, 200);</span></span><br><span class="line">Point.factor = <span class="number">10</span>;</span><br><span class="line">Point.printZValue(); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>根据上述代码：</p>
<ol>
<li>我们知道使用 class 关键字来创建类；</li>
<li>在属性或者方法前使用 static 关键字来创建类属性和方法；</li>
<li>使用<code>.</code>语法来调用对象的属性或者方法；</li>
<li>使用类名来声明构造函数。</li>
</ol>
<p>值得一提的是，Dart 中并没有 public、protected、private 这些关键字，我们只要在声明变量与方法时，在前面加上<code>_</code>即可作为 private 方法使用。如果不加<code>_</code>，则默认为 public。<strong>不过，“_”的限制范围并不是类访问级别的，而是库访问级别。</strong></p>
<h2 id="实例变量（instance-variable）"><a href="#实例变量（instance-variable）" class="headerlink" title="实例变量（instance variable）"></a>实例变量（instance variable）</h2><p>下面是如何定义实例变量的示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x; <span class="comment">// Declare instance variable x, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> y; <span class="comment">// Declare y, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// Declare z, initially 0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上述代码我们知道如何去定义实例变量，并且我们可以给我们定义实例变量赋初始值；如果没有初始值，默认都是 null。</p>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数使我们创建实例对象的方法。我们可以在构造方法对实例变量进行初始化操作。在 Dart 中，我们的构造函数可以分为三种：</p>
<ul>
<li>默认构造函数</li>
<li>自定义默认构造函数</li>
<li>命名构造函数</li>
</ul>
<h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>如果你没有定义构造函数，则会有个默认构造函数。 默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point p = Point();</span><br><span class="line"><span class="comment">// p.x 和 p.y 为 null。</span></span><br></pre></td></tr></table></figure>

<p>如果想上述代码定义<code>Point</code>类，那么系统会默认创建了<code>Point()</code>构造函数；我们可以使用该构造函数创建<code>Point</code>对象。</p>
<h3 id="自定义默认构造函数"><a href="#自定义默认构造函数" class="headerlink" title="自定义默认构造函数"></a>自定义默认构造函数</h3><p>与默认构造函数类似，都是用类名来声明的；区别在于自定义的构造函数具有参数列表。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：无论是默认构造函数还是自定义默认构造函数，都只能有一个。</strong></p>
<h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">'x'</span>];</span><br><span class="line">    y = json[<span class="string">'y'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过上述实例，我们可以看到<code>Point.fromJson</code>就是一个命名构造函数。如果我们想要定义命名构造函数，我们可以使用<code>ClassName.identifier</code>的形式来定义。</p>
<h3 id="构造函数的调用过程"><a href="#构造函数的调用过程" class="headerlink" title="构造函数的调用过程"></a>构造函数的调用过程</h3><ul>
<li>初始化参数列表</li>
<li>父类的构造函数</li>
<li>类本身构造函数</li>
</ul>
<h3 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h3><p>重定向构造函数，就是本身没有任何代码，只是调用类本身的其他构造函数去创建对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) : <span class="keyword">this</span>(json[<span class="string">'x'</span>], <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h3><p>如果我们的类提供一个状态不变的对象，可以把这些对象定义为编译时常量。要实现这个功能，需要使用<code>const</code>来定义常量构造函数，并且使用<code>final</code>来声明所有类的变量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> zero = <span class="keyword">const</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="工厂方法构造函数"><a href="#工厂方法构造函数" class="headerlink" title="工厂方法构造函数"></a>工厂方法构造函数</h3><p>如果一个构造函数并不总是返回一个新的对象，则使用 <code>factory</code> 来定义 这个构造函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to the _ in front</span></span><br><span class="line">  <span class="comment">// of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) &#123;</span><br><span class="line">      <span class="built_in">print</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据上面代码，我们使用<code>factory</code>定义了名为<code>Logger</code>的构造函数；在该方法中我们根据<code>name</code>来查找是否创建过<code>name</code>名称的对象；若存在，直接返回该对象；若不存在，则创建新的对象，并将对象以<code>name</code>名称存入<code>_cache</code>字典中。</p>
<p><strong>注意： 工厂构造函数无法访问 this。</strong></p>
<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性就是类的特征、状态。在 Dart 中，属性的定义和变量的定义是一致的，我们可以用类型、var、final来定义。</p>
<p>一般情况下，我们定义的属性都会隐式创建Setter和Getter函数，它们是用来设置和访问对象属性的特殊函数。但是，如果我们使用final来定义属性的时候，属性只有Getter函数，不会存在Setter函数。</p>
<p>除了系统可以隐式创建属性的Setter和Getter函数外，我们可以通过set和get关键字来手动创建Setter和Getter函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getter 和 setter 的好处是，你可以开始使用实例变量，后来 你可以把实例变量用函数包裹起来，而调用你代码的地方不需要修改。</p>
<p><strong>注意： 像 (++) 这种操作符不管是否定义 getter 都会正确的执行。 为了避免其他副作用， 操作符只调用 getter 一次，然后 把其值保存到一个临时变量中。</strong></p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是类中定义的方法，是类对象的行为。类中函数的定义和方法类似。在函数中，我们可以使用<code>this</code>来表示类的实例对象。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="类变量和函数"><a href="#类变量和函数" class="headerlink" title="类变量和函数"></a>类变量和函数</h2><p>使用 <code>static</code> 关键字来实现类级别的变量和函数。</p>
<ul>
<li>静态变量在第一次使用的时候才被初始化。</li>
<li>静态函数不再类实例上执行， 所以无法访问 <code>this</code>。</li>
<li>静态函数还可以当做编译时常量使用。例如， 你可以把静态函数当做常量构造函数的参数来使用。</li>
</ul>
<p>class Color {<br>  final String name;<br>  const Color(this.name);<br>  static const red = const Color(‘red’); // A constant static variable.<br>  static Color green() {<br>    return Color(‘green’);<br>  }<br>}</p>
<h2 id="创建一个子类"><a href="#创建一个子类" class="headerlink" title="创建一个子类"></a>创建一个子类</h2><p>在 Dart 中，我们使用 <code>extends</code> 定义子类，使用来 <code>supper</code> 引用超类。并且我们可以在子类中重载父类的函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p>每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口。如果你想 创建类 A 来支持 类 B 的 api，而不想继承 B 的实现， 则类 A 应该实现 B 的接口。</p>
<p>一个类可以通过 <code>implements</code> 关键字来实现一个或者多个接口， 并实现每个接口定义的 API。 例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A person. The implicit interface contains greet().</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In the interface, but visible only in this library.</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not in the interface, since this is a constructor.</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the interface.</span></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of the Person interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We have to define this, but we don't use it.</span></span><br><span class="line">  <span class="keyword">final</span> _name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hi <span class="subst">$who</span>. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Person(<span class="string">'kathy'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Imposter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h2><p>实例函数、 getter、和 setter 函数可以为抽象函数， 抽象函数是只定义函数接口但是没有实现的函数，由子类来 实现该函数。如果用分号来替代函数体则这个函数就是抽象函数。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define instance variables and methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// Define an abstract method.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// ...Provide an implementation, so the method is not abstract here...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意：我们只能使用抽象类的子类，抽象类本身是不能使用的</strong></p>
<h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型通常称之为 enumerations 或者 enums， 是一种特殊的类，用来表现一个固定数目的常量。我们可以使用 <code>enum</code> 来定义：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型中的每个值都有一个 index getter 函数， 该函数返回该值在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的位置为 0， 第二个为 1.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.green.index == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.blue.index == <span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>枚举的 values 常量可以返回 所有的枚举值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure>

<p>可以在 switch 语句中使用枚举。 如果在 switch (e) 中的 e 的类型为枚举类，如果你没有处理所有该枚举类型的值的话，则会抛出一个警告：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Color aColor = Color.blue;</span><br><span class="line"><span class="keyword">switch</span> (aColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> Color.red:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Red as roses!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Color.green:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Green as grass!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// Without this, you see a WARNING.</span></span><br><span class="line">    <span class="built_in">print</span>(aColor);  <span class="comment">// 'Color.blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举类型具有如下的限制：</p>
<ul>
<li>无法继承枚举类型、无法使用 mix in、无法实现一个枚举类型</li>
<li>无法显示的初始化一个枚举类型</li>
</ul>
<h2 id="可调用的类"><a href="#可调用的类" class="headerlink" title="可调用的类"></a>可调用的类</h2><p>如果 Dart 类实现了 call() 函数则 可以当做方法来调用。</p>
<p>在下面的示例中，WannabeFunction 类定义了一个 call() 方法，该方法有三个字符串参数，并且返回三个字符串 串联起来的结果。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$out</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">范小忧</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://heyor.github.io/2019/08/21/Dart类/">https://heyor.github.io/2019/08/21/Dart类/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://heyor.github.io">范小忧</a>！</span></div></div><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Dart/">Dart</a><a class="post-meta__tags" href="/tags/Flutter/">Flutter</a></div><nav id="pagination"><div class="next-post pull-right"><a href="/2019/08/21/Dart函数/"><span>Dart 函数</span><i class="fa fa-chevron-right"></i></a></div></nav></div></div><footer class="footer-bg" style="background-image: url(http://i0.hdslb.com/bfs/article/3b46e7336296964c01560257a5c561ae40f0e861.jpg)"><div class="layout" id="footer"><div class="copyright">&copy;2019 By 范小忧</div><div class="framework-info"><span>驱动 - </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 - </span><a href="https://github.com/Molunerfinn/hexo-theme-melody"><span>Melody</span></a></div><div class="busuanzi"><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv"><i class="fa fa-file-o"></i><span id="busuanzi_value_page_pv"></span><span></span></span></div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@latest/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-ui-pack@latest/velocity.ui.min.js"></script><script src="/js/utils.js?version=1.6.1"></script><script src="/js/fancybox.js?version=1.6.1"></script><script src="/js/sidebar.js?version=1.6.1"></script><script src="/js/copy.js?version=1.6.1"></script><script src="/js/fireworks.js?version=1.6.1"></script><script src="/js/transition.js?version=1.6.1"></script><script src="/js/scroll.js?version=1.6.1"></script><script src="/js/head.js?version=1.6.1"></script><script>if(/Android|webOS|iPhone|iPod|BlackBerry/i.test(navigator.userAgent)) {
  $('#nav').addClass('is-mobile')
  $('footer').addClass('is-mobile')
}</script></body></html>