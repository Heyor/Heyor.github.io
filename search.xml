<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>State 的生命周期</title>
      <link href="/2019/08/30/State%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
      <url>/2019/08/30/State%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>前言：生命周期对于一个移动开发者来说并不陌生，它使我们精通移动开发的必修课。对于 Flutter 来说也是必不可缺少的。在 Flutter 中我们需要关注的是<strong>App的生命周期</strong>和<strong>StatefulWidget的生命周期</strong>；今天我们详细的了学习下<strong>StatefulWidget的生命周期</strong>。</p><p><img src="/images/statelifecycle.png" alt></p><p>通过上图我们可以认为 StatefulWidget 的生命周期大致分为</p><ol><li>初始化阶段：<code>createState</code> =&gt; <code>initState</code> =&gt; <code>didChangeDependencies</code> =&gt; <code>build</code>;</li><li>界面刷新阶段：<code>setState</code>  =&gt; <code>build</code> 或者 <code>inheritedWidget rebuild</code> =&gt; <code>didChangeDependencies</code> =&gt; <code>build</code> 或者 <code>didUpdateWidget</code> =&gt; <code>didChangeDependencies</code>;</li><li>销毁阶段：<code>deactivite</code> =&gt; <code>dispose</code>。</li></ol><a id="more"></a><p>下面我们介绍下各方法都在什么时候调用？</p><ul><li>initState(): state create之后被insert到tree时调用的</li><li>didChangeDependencies():<ol><li>初始化时，在initState()之后立刻调用</li><li>当依赖的InheritedWidget rebuild,会触发此接口被调用</li></ol></li><li>build():<ol><li>didChangeDependencies() 调用之后</li><li>didUpdateWidget() 调用之后</li><li>使用 setState() 更新状态之后</li></ol></li><li>didUpdateWidget(): 父先节点rebuild widget时调用</li><li>deactivate():Widget被remove的时候调用，一个Widget从tree中remove掉，可以在dispose接口被调用前，重新instert到一个新tree中</li><li>dispose():Widget彻底销毁时调用</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter 从零到1搭建第一个应用程序</title>
      <link href="/2019/08/23/Flutter%E4%BB%8E%E9%9B%B6%E5%88%B01%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/"/>
      <url>/2019/08/23/Flutter%E4%BB%8E%E9%9B%B6%E5%88%B01%E6%90%AD%E5%BB%BA%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>前面我们学习开发 Flutter 应用所需的编程语言 Dart。今天我们来一步一步介绍如何介绍如何创建 Flutter 应用程序。废话不多说，我们直接进入正题：</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Flutter 是 Google 推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter 提供了丰富的组件、接口，开发者可以很快地为 Flutter 添加 native 扩展。同时 Flutter 还使用 Native 引擎渲染视图，这无疑能为用户提供良好的体验。</p><a id="more"></a><p><strong>Flutter 的特点：</strong></p><ol><li>采用Dart语言开发，为什么不使用其他语言呢？因为Dart团队就在隔壁；</li><li>跨平台自绘引擎，Flutter使用Skia作为其2D渲染引擎；</li><li>高性能，Flutter APP采用Dart语言开发；而Dart语言不仅支持JIT（即时编译），还支持AOT；同时Flutter使用自己的渲染引擎来绘制UI，布局数据等由Dart语言直接控制。</li></ol><p><strong>Flutter框架结构</strong></p><p><img src="https://cdn.jsdelivr.net/gh/flutterchina/flutter-in-action/docs/imgs/1-1.png" alt></p><p>通过上图我们可以看出来，整体的框架分为Framework和Engine两大部分。 </p><p>Framework为我们提供了UI和用户交互能力。首先，底部的Foundation和Animation、Painting、Gestures为我们提供动画、手势、UI绘制和与Engine的交互能力。其次，Rendering层会根据我们编写Widget生成相应UI树，它类似于React中的虚拟DOM，是我们Flutter UI框架的核心；最后，也是我们日常开发中打交道最多的Widgets，我们可以把Widgets看成描述UI组件的配置，在Flutter中为我们提供了Material（安卓）和Cupertino（iOS）两种风格的Widgets。</p><p>Engine这是一个纯 C++实现的 SDK，其中包括了 Skia引擎、Dart运行时、文字排版引擎等。在代码调用 dart:ui库时，调用最终会走到Engine层，然后实现真正的绘制逻辑。</p><h1 id="搭建Flutter开发环境"><a href="#搭建Flutter开发环境" class="headerlink" title="搭建Flutter开发环境"></a>搭建Flutter开发环境</h1><p>阅读完上面我们已经大致了解了Flutter，那么下面我们就来搭建Flutter开发环境吧。由于我使用Mac电脑进行开发的，所有这里就以Mac为例。如果你是Windows或者Liunx，请移步<a href="https://flutter.dev/docs/get-started/install" target="_blank" rel="noopener">官网</a></p><h2 id="使用镜像"><a href="#使用镜像" class="headerlink" title="使用镜像"></a>使用镜像</h2><p>由于在国内访问Flutter有时可能会受到限制，Flutter官方为中国开发者搭建了临时镜像，我们可以将如下环境变量加入到用户环境变量（~/.zshrc或者~/.bash_profile）中：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line"><span class="built_in">export</span> FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure><p><strong>注意： 此镜像为临时镜像，并不能保证一直可用，如果失效可以参考<a href="https://flutter.io/community/china" target="_blank" rel="noopener">https://flutter.io/community/china</a> 以获得有关镜像服务器的最新动态。</strong></p><h2 id="下载Flutter-SDK"><a href="#下载Flutter-SDK" class="headerlink" title="下载Flutter SDK"></a>下载Flutter SDK</h2><p>配置完镜像之后，我们可以去<a href="https://flutter.dev/docs/development/tools/sdk/releases" target="_blank" rel="noopener">官网下载</a>，并将解压安装包；也可以使用Git来下载，Git命令如下：</p><figure class="highlight zsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> -b master https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure><p><strong>注意：无论是解压还是Git克隆的SDK，我们都需要记住flutter文件夹的路径。</strong></p><p><img src="/images/2019082301.jpg" alt></p><h2 id="更新环境变量"><a href="#更新环境变量" class="headerlink" title="更新环境变量"></a>更新环境变量</h2><p>有了Flutter SDK后，我们还需要将<code>export PATH=$HOME/flutter/bin:$PATH</code>加入到用户环境变量（~/.zshrc或者~/.bash_profile）中，才能正常使用：</p><p><img src="/images/2019082302.jpg" alt></p><p><strong>注意：这里的<code>$HOME/flutter</code>就是我们<code>flutter文件夹的路径</code>，你完全可以替换成你电脑上的路径。</strong></p><p>配置完成之后，我们可以使用<code>flutter version</code>来检查我们的环境变量是否配置成功了；如果终端打印如下，则表示配置成功了：</p><p><img src="/images/2019082303.jpg" alt></p><h2 id="运行-flutter-doctor命令"><a href="#运行-flutter-doctor命令" class="headerlink" title="运行 flutter doctor命令"></a>运行 flutter doctor命令</h2><p>如果上述步骤一切顺利的话，我们离成功配置完环境就只有一部之遥（吐槽下这一部需要的东西还挺多的）。我们先在终端中运行<code>$ flutter doctor</code>，结果类似于下图：</p><p><img src="/images/2019082304.jpg" alt></p><p>其中Flutter、Android toolchain、Xcode、Android Studio和Connected device必需和上图一样安装成功；IntelliJ IDEA Ultimate Edition和VS Code不是必需的，如果你想用这两种开发工具进行开发，那么就需要安装成功了。下面我就来解释下为什么有的需要安装，有的则不一定需要。</p><ol><li>Flutter：代表Flutter SDK，所以必须要安装（你不装试试！）；</li><li>Android toolchain：安卓编译器，其实不想装也行；后果就是代码不能在安卓上奔跑；</li><li>Xcode：iOS开发工具，自带编译器和模拟器；如果你还是不想装，那我只能说别闹了；</li><li>Android Studio、IntelliJ IDEA Ultimate Edition和VS Code三者你只需要安装一个就行了，它们都是开发工具，无论用哪个都能开发。我建议安装Android Studio，因为这样我们安装Android toolchain比较方便，但是真的卡（很卡很卡）；</li><li>Connected device：连接设备，真机模拟都行；基本上安装上述后，会默认安装成功的（Xcode自带模拟器）。</li></ol><br>说了那么多，我们基本上就知道了那些是我们需要安装的，下面我们就来一步步安装：<ol><li>下载Xcode，去App Store下载即可，记得下载完一定要打开下哦；<br><img src="/images/2019082305.jpg" alt></li><li><a href="http://www.android-studio.org" target="_blank" rel="noopener">下载 Android Studio</a>，并根据安装引导下载Android SDK；</li><li>打开Android Studio，下载Dart和Flutter插件；<br><img src="/images/2019082306.jpg" alt></li></ol><h1 id="创建一个-Flutter-App"><a href="#创建一个-Flutter-App" class="headerlink" title="创建一个 Flutter App"></a>创建一个 Flutter App</h1><ol><li>打开 Android Studio，选择<code>Start a new Flutter project</code>;<br><img src="/images/2019082701.jpg" alt></li><li>选择 <code>Flutter Application</code>，然后点击’下一步’;<br><img src="/images/2019082702.jpg" alt></li><li>填写项目名称、存储路径，然后点击’下一步’;<br><img src="/images/2019082703.jpg" alt></li><li>若需要支持 Swift 或 Kotlin 可以选择，若没有特殊需求；则直接点击<code>Finish</code>,即可完成项目的创建。<br><img src="/images/2019082704.jpg" alt></li></ol><h1 id="项目的目录结构"><a href="#项目的目录结构" class="headerlink" title="项目的目录结构"></a>项目的目录结构</h1><img src="/images/2019082705.jpg" width="400"><ol><li>lib: 存放我们编写的 dart 文件的地方，其中<code>main.dart</code>文件是App的整体入口；</li><li>android: 存放与安卓相关的东西；</li><li>ios: 存放与苹果相关的东西；</li><li>pubspec.ymal: 包管理，资源配置文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Flutter </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 中的类</title>
      <link href="/2019/08/21/Dart%E7%B1%BB/"/>
      <url>/2019/08/21/Dart%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>Dart是一种面向对象的语言，具有类和基于mixin的继承。每个对象都是一个类的实例，所有类都来自Object。接下来，我们以一个具体的案例看看Dart 是如何定义和使用类。</p><h2 id="如何定义和使用类"><a href="#如何定义和使用类" class="headerlink" title="如何定义和使用类"></a>如何定义和使用类</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x, y;</span><br><span class="line">  <span class="keyword">static</span> <span class="built_in">num</span> factor = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 语法糖，等同于在函数体内：this.x = x;this.y = y;</span></span><br><span class="line">  Point(<span class="keyword">this</span>.x,<span class="keyword">this</span>.y);</span><br><span class="line">  <span class="keyword">void</span> printInfo() =&gt; <span class="built_in">print</span>(<span class="string">'(<span class="subst">$x</span>, <span class="subst">$y</span>)'</span>);</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">void</span> printZValue() =&gt; <span class="built_in">print</span>(<span class="string">'<span class="subst">$factor</span>'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Point(<span class="number">100</span>,<span class="number">200</span>); <span class="comment">// new 关键字可以省略</span></span><br><span class="line">p.printInfo();  <span class="comment">// 输出 (100, 200);</span></span><br><span class="line">Point.factor = <span class="number">10</span>;</span><br><span class="line">Point.printZValue(); <span class="comment">// 输出 10</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>根据上述代码：</p><ol><li>我们知道使用 class 关键字来创建类；</li><li>在属性或者方法前使用 static 关键字来创建类属性和方法；</li><li>使用<code>.</code>语法来调用对象的属性或者方法；</li><li>使用类名来声明构造函数。</li></ol><p>值得一提的是，Dart 中并没有 public、protected、private 这些关键字，我们只要在声明变量与方法时，在前面加上<code>_</code>即可作为 private 方法使用。如果不加<code>_</code>，则默认为 public。<strong>不过，“_”的限制范围并不是类访问级别的，而是库访问级别。</strong></p><h2 id="实例变量（instance-variable）"><a href="#实例变量（instance-variable）" class="headerlink" title="实例变量（instance variable）"></a>实例变量（instance variable）</h2><p>下面是如何定义实例变量的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x; <span class="comment">// Declare instance variable x, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> y; <span class="comment">// Declare y, initially null.</span></span><br><span class="line">  <span class="built_in">num</span> z = <span class="number">0</span>; <span class="comment">// Declare z, initially 0.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上述代码我们知道如何去定义实例变量，并且我们可以给我们定义实例变量赋初始值；如果没有初始值，默认都是 null。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>构造函数使我们创建实例对象的方法。我们可以在构造方法对实例变量进行初始化操作。在 Dart 中，我们的构造函数可以分为三种：</p><ul><li>默认构造函数</li><li>自定义默认构造函数</li><li>命名构造函数</li></ul><h3 id="默认构造函数"><a href="#默认构造函数" class="headerlink" title="默认构造函数"></a>默认构造函数</h3><p>如果你没有定义构造函数，则会有个默认构造函数。 默认构造函数没有参数，并且会调用超类的 没有参数的构造函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point p = Point();</span><br><span class="line"><span class="comment">// p.x 和 p.y 为 null。</span></span><br></pre></td></tr></table></figure><p>如果想上述代码定义<code>Point</code>类，那么系统会默认创建了<code>Point()</code>构造函数；我们可以使用该构造函数创建<code>Point</code>对象。</p><h3 id="自定义默认构造函数"><a href="#自定义默认构造函数" class="headerlink" title="自定义默认构造函数"></a>自定义默认构造函数</h3><p>与默认构造函数类似，都是用类名来声明的；区别在于自定义的构造函数具有参数列表。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：无论是默认构造函数还是自定义默认构造函数，都只能有一个。</strong></p><h3 id="命名构造函数"><a href="#命名构造函数" class="headerlink" title="命名构造函数"></a>命名构造函数</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) &#123;</span><br><span class="line">    x = json[<span class="string">'x'</span>];</span><br><span class="line">    y = json[<span class="string">'y'</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述实例，我们可以看到<code>Point.fromJson</code>就是一个命名构造函数。如果我们想要定义命名构造函数，我们可以使用<code>ClassName.identifier</code>的形式来定义。</p><h3 id="构造函数的调用过程"><a href="#构造函数的调用过程" class="headerlink" title="构造函数的调用过程"></a>构造函数的调用过程</h3><ul><li>初始化参数列表</li><li>父类的构造函数</li><li>类本身构造函数</li></ul><h3 id="重定向构造函数"><a href="#重定向构造函数" class="headerlink" title="重定向构造函数"></a>重定向构造函数</h3><p>重定向构造函数，就是本身没有任何代码，只是调用类本身的其他构造函数去创建对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">int</span> x;</span><br><span class="line">  <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  Point.fromJson(<span class="built_in">Map</span> json) : <span class="keyword">this</span>(json[<span class="string">'x'</span>], <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="常量构造函数"><a href="#常量构造函数" class="headerlink" title="常量构造函数"></a>常量构造函数</h3><p>如果我们的类提供一个状态不变的对象，可以把这些对象定义为编译时常量。要实现这个功能，需要使用<code>const</code>来定义常量构造函数，并且使用<code>final</code>来声明所有类的变量。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> x;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> y;</span><br><span class="line"></span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> zero = <span class="keyword">const</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="工厂方法构造函数"><a href="#工厂方法构造函数" class="headerlink" title="工厂方法构造函数"></a>工厂方法构造函数</h3><p>如果一个构造函数并不总是返回一个新的对象，则使用 <code>factory</code> 来定义 这个构造函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> name;</span><br><span class="line">  <span class="built_in">bool</span> mute = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// _cache is library-private, thanks to the _ in front</span></span><br><span class="line">  <span class="comment">// of its name.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">final</span> <span class="built_in">Map</span>&lt;<span class="built_in">String</span>, Logger&gt; _cache =</span><br><span class="line">      &lt;<span class="built_in">String</span>, Logger&gt;&#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">factory</span> Logger(<span class="built_in">String</span> name) &#123;</span><br><span class="line">    <span class="keyword">if</span> (_cache.containsKey(name)) &#123;</span><br><span class="line">      <span class="keyword">return</span> _cache[name];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">final</span> logger = <span class="keyword">new</span> Logger._internal(name);</span><br><span class="line">      _cache[name] = logger;</span><br><span class="line">      <span class="keyword">return</span> logger;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Logger._internal(<span class="keyword">this</span>.name);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> log(<span class="built_in">String</span> msg) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!mute) &#123;</span><br><span class="line">      <span class="built_in">print</span>(msg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面代码，我们使用<code>factory</code>定义了名为<code>Logger</code>的构造函数；在该方法中我们根据<code>name</code>来查找是否创建过<code>name</code>名称的对象；若存在，直接返回该对象；若不存在，则创建新的对象，并将对象以<code>name</code>名称存入<code>_cache</code>字典中。</p><p><strong>注意： 工厂构造函数无法访问 this。</strong></p><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>属性就是类的特征、状态。在 Dart 中，属性的定义和变量的定义是一致的，我们可以用类型、var、final来定义。</p><p>一般情况下，我们定义的属性都会隐式创建Setter和Getter函数，它们是用来设置和访问对象属性的特殊函数。但是，如果我们使用final来定义属性的时候，属性只有Getter函数，不会存在Setter函数。</p><p>除了系统可以隐式创建属性的Setter和Getter函数外，我们可以通过set和get关键字来手动创建Setter和Getter函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> left;</span><br><span class="line">  <span class="built_in">num</span> top;</span><br><span class="line">  <span class="built_in">num</span> width;</span><br><span class="line">  <span class="built_in">num</span> height;</span><br><span class="line"></span><br><span class="line">  Rectangle(<span class="keyword">this</span>.left, <span class="keyword">this</span>.top, <span class="keyword">this</span>.width, <span class="keyword">this</span>.height);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Define two calculated properties: right and bottom.</span></span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> right             =&gt; left + width;</span><br><span class="line">      <span class="keyword">set</span> right(<span class="built_in">num</span> value)  =&gt; left = value - width;</span><br><span class="line">  <span class="built_in">num</span> <span class="keyword">get</span> bottom            =&gt; top + height;</span><br><span class="line">      <span class="keyword">set</span> bottom(<span class="built_in">num</span> value) =&gt; top = value - height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>, <span class="number">20</span>, <span class="number">15</span>);</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">3</span>);</span><br><span class="line">  rect.right = <span class="number">12</span>;</span><br><span class="line">  <span class="keyword">assert</span>(rect.left == <span class="number">-8</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>getter 和 setter 的好处是，你可以开始使用实例变量，后来 你可以把实例变量用函数包裹起来，而调用你代码的地方不需要修改。</p><p><strong>注意： 像 (++) 这种操作符不管是否定义 getter 都会正确的执行。 为了避免其他副作用， 操作符只调用 getter 一次，然后 把其值保存到一个临时变量中。</strong></p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是类中定义的方法，是类对象的行为。类中函数的定义和方法类似。在函数中，我们可以使用<code>this</code>来表示类的实例对象。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'dart:math'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="built_in">num</span> x;</span><br><span class="line">  <span class="built_in">num</span> y;</span><br><span class="line">  Point(<span class="keyword">this</span>.x, <span class="keyword">this</span>.y);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">num</span> distanceTo(Point other) &#123;</span><br><span class="line">    <span class="keyword">var</span> dx = x - other.x;</span><br><span class="line">    <span class="keyword">var</span> dy = y - other.y;</span><br><span class="line">    <span class="keyword">return</span> sqrt(dx * dx + dy * dy);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="类变量和函数"><a href="#类变量和函数" class="headerlink" title="类变量和函数"></a>类变量和函数</h2><p>使用 <code>static</code> 关键字来实现类级别的变量和函数。</p><ul><li>静态变量在第一次使用的时候才被初始化。</li><li>静态函数不再类实例上执行， 所以无法访问 <code>this</code>。</li><li>静态函数还可以当做编译时常量使用。例如， 你可以把静态函数当做常量构造函数的参数来使用。</li></ul><p>class Color {<br>  final String name;<br>  const Color(this.name);<br>  static const red = const Color(‘red’); // A constant static variable.<br>  static Color green() {<br>    return Color(‘green’);<br>  }<br>}</p><h2 id="创建一个子类"><a href="#创建一个子类" class="headerlink" title="创建一个子类"></a>创建一个子类</h2><p>在 Dart 中，我们使用 <code>extends</code> 定义子类，使用来 <code>supper</code> 引用超类。并且我们可以在子类中重载父类的函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    _illuminateDisplay();</span><br><span class="line">    _activateIrSensor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartTelevision</span> <span class="keyword">extends</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> turnOn() &#123;</span><br><span class="line">    <span class="keyword">super</span>.turnOn();</span><br><span class="line">    _bootNetworkInterface();</span><br><span class="line">    _initializeMemory();</span><br><span class="line">    _upgradeApps();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="隐式接口"><a href="#隐式接口" class="headerlink" title="隐式接口"></a>隐式接口</h2><p>每个类都隐式的定义了一个包含所有实例成员的接口， 并且这个类实现了这个接口。如果你想 创建类 A 来支持 类 B 的 api，而不想继承 B 的实现， 则类 A 应该实现 B 的接口。</p><p>一个类可以通过 <code>implements</code> 关键字来实现一个或者多个接口， 并实现每个接口定义的 API。 例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A person. The implicit interface contains greet().</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// In the interface, but visible only in this library.</span></span><br><span class="line">  <span class="keyword">final</span> _name;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not in the interface, since this is a constructor.</span></span><br><span class="line">  Person(<span class="keyword">this</span>._name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// In the interface.</span></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hello, <span class="subst">$who</span>. I am <span class="subst">$_name</span>.'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An implementation of the Person interface.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Imposter</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We have to define this, but we don't use it.</span></span><br><span class="line">  <span class="keyword">final</span> _name = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">String</span> greet(who) =&gt; <span class="string">'Hi <span class="subst">$who</span>. Do you know who I am?'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">greetBob(Person person) =&gt; person.greet(<span class="string">'bob'</span>);</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Person(<span class="string">'kathy'</span>)));</span><br><span class="line">  <span class="built_in">print</span>(greetBob(<span class="keyword">new</span> Imposter()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="抽象函数"><a href="#抽象函数" class="headerlink" title="抽象函数"></a>抽象函数</h2><p>实例函数、 getter、和 setter 函数可以为抽象函数， 抽象函数是只定义函数接口但是没有实现的函数，由子类来 实现该函数。如果用分号来替代函数体则这个函数就是抽象函数。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...Define instance variables and methods...</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> doSomething(); <span class="comment">// Define an abstract method.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EffectiveDoer</span> <span class="keyword">extends</span> <span class="title">Doer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> doSomething() &#123;</span><br><span class="line">    <span class="comment">// ...Provide an implementation, so the method is not abstract here...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：我们只能使用抽象类的子类，抽象类本身是不能使用的</strong></p><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>枚举类型通常称之为 enumerations 或者 enums， 是一种特殊的类，用来表现一个固定数目的常量。我们可以使用 <code>enum</code> 来定义：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Color &#123;</span><br><span class="line">  red,</span><br><span class="line">  green,</span><br><span class="line">  blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型中的每个值都有一个 index getter 函数， 该函数返回该值在枚举类型定义中的位置（从 0 开始）。 例如，第一个枚举值的位置为 0， 第二个为 1.</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">assert</span>(Color.red.index == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.green.index == <span class="number">1</span>);</span><br><span class="line"><span class="keyword">assert</span>(Color.blue.index == <span class="number">2</span>);</span><br></pre></td></tr></table></figure><p>枚举的 values 常量可以返回 所有的枚举值。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;Color&gt; colors = Color.values;</span><br><span class="line"><span class="keyword">assert</span>(colors[<span class="number">2</span>] == Color.blue);</span><br></pre></td></tr></table></figure><p>可以在 switch 语句中使用枚举。 如果在 switch (e) 中的 e 的类型为枚举类，如果你没有处理所有该枚举类型的值的话，则会抛出一个警告：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Color aColor = Color.blue;</span><br><span class="line"><span class="keyword">switch</span> (aColor) &#123;</span><br><span class="line">  <span class="keyword">case</span> Color.red:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Red as roses!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> Color.green:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Green as grass!'</span>);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">// Without this, you see a WARNING.</span></span><br><span class="line">    <span class="built_in">print</span>(aColor);  <span class="comment">// 'Color.blue'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举类型具有如下的限制：</p><ul><li>无法继承枚举类型、无法使用 mix in、无法实现一个枚举类型</li><li>无法显示的初始化一个枚举类型</li></ul><h2 id="可调用的类"><a href="#可调用的类" class="headerlink" title="可调用的类"></a>可调用的类</h2><p>如果 Dart 类实现了 call() 函数则 可以当做方法来调用。</p><p>在下面的示例中，WannabeFunction 类定义了一个 call() 方法，该方法有三个字符串参数，并且返回三个字符串 串联起来的结果。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WannabeFunction</span> </span>&#123;</span><br><span class="line">  call(<span class="built_in">String</span> a, <span class="built_in">String</span> b, <span class="built_in">String</span> c) =&gt; <span class="string">'<span class="subst">$a</span> <span class="subst">$b</span> <span class="subst">$c</span>!'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main() &#123;</span><br><span class="line">  <span class="keyword">var</span> wf = <span class="keyword">new</span> WannabeFunction();</span><br><span class="line">  <span class="keyword">var</span> out = wf(<span class="string">"Hi"</span>,<span class="string">"there,"</span>,<span class="string">"gang"</span>);</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">'<span class="subst">$out</span>'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 函数</title>
      <link href="/2019/08/21/Dart%E5%87%BD%E6%95%B0/"/>
      <url>/2019/08/21/Dart%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p>作为一门成熟的语言，函数是必不可少的组成部分。在 Dart 中，函数（Function）也是对象，它的类型是 <code>Function</code>。这意味着，方法可以赋值给变量，也可以当做其他方法的参数。 也可以把 Dart 类的实例当做方法来调用。</p><a id="more"></a><h2 id="如何定义一个函数"><a href="#如何定义一个函数" class="headerlink" title="如何定义一个函数"></a>如何定义一个函数</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述实例，我们可以看到函数包括返回值类型、名称、参数列表和函数体。除了标准的写法外，在 Dart 中，我们可以省略返回值类型。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNoble(<span class="built_in">int</span> atomicNumber) &#123;</span><br><span class="line">  <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并且当我们的函数中只有一行表达式时，我们还可以使用<code>=&gt;</code>胖箭头语法来编写。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">isNoble(<span class="built_in">int</span> atomicNumber) =&gt; <span class="keyword">return</span> _nobleGases[atomicNumber] != <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h2 id="函数的名称"><a href="#函数的名称" class="headerlink" title="函数的名称"></a>函数的名称</h2><p>在定义函数的时候，我们需要给函数起一个名字，用来方便我们调用函数。函数名的规则和我们变量名的规则是一致的。</p><ul><li>都是由下划线、字母和数字组成的；</li><li>必须以下划线或者字母开头；</li><li>都不能使用关键字。</li></ul><h2 id="函数的参数列表"><a href="#函数的参数列表" class="headerlink" title="函数的参数列表"></a>函数的参数列表</h2><p>函数的参数可以有两种类型的参数：必需的和可选的。 必需的参数在参数列表前面， 后面是可选参数。可选参数可以是命名参数或者位置参数，但是这两种参数不能同时当做可选参数。在实际开发中，我们使用命名参数会比较多。</p><h3 id="命名参数"><a href="#命名参数" class="headerlink" title="命名参数"></a>命名参数</h3><p>在定义方法的时候，使用 {param1, param2, …} 的形式来指定命名参数：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">enableFlags(&#123;<span class="built_in">bool</span> bold, <span class="built_in">bool</span> hidden&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用函数时，命名参数的使用</span></span><br><span class="line">enableFlags(hidden: <span class="keyword">false</span>);</span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>, hidden: <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>把一些方法的参数放到 [] 中就变成可选 位置参数了：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> say(<span class="built_in">String</span> from, <span class="built_in">String</span> msg, [<span class="built_in">String</span> device]) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="string">'<span class="subst">$from</span> says <span class="subst">$msg</span>'</span>;</span><br><span class="line">  <span class="keyword">if</span> (device != <span class="keyword">null</span>) &#123;</span><br><span class="line">    result = <span class="string">'<span class="subst">$result</span> with a <span class="subst">$device</span>'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 调用函数时，位置参数的使用</span></span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>) == <span class="string">'Bob says Howdy'</span>);</span><br><span class="line"><span class="keyword">assert</span>(say(<span class="string">'Bob'</span>, <span class="string">'Howdy'</span>, <span class="string">'smoke signal'</span>) == <span class="string">'Bob says Howdy with a smoke signal'</span>);</span><br></pre></td></tr></table></figure><h3 id="参数的默认值"><a href="#参数的默认值" class="headerlink" title="参数的默认值"></a>参数的默认值</h3><p>在定义方法的时候，可以使用 = 来定义可选参数的默认值。 默认值只能是编译时常量。 如果没有提供默认值，则默认值为 null。<br>下面是设置可选参数默认值的示例：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// Sets the [bold] and [hidden] flags to the values you</span></span><br><span class="line"><span class="comment">/// specify, defaulting to false.</span></span><br><span class="line"><span class="keyword">void</span> enableFlags(&#123;<span class="built_in">bool</span> bold = <span class="keyword">false</span>, <span class="built_in">bool</span> hidden = <span class="keyword">false</span>&#125;) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bold will be true; hidden will be false.</span></span><br><span class="line">enableFlags(bold: <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li>在旧版本中，我们会使用<code>:</code>来代替<code>=</code>设置默认值。但在 Dart SDK 1.21 之后，就必须使用<code>=</code>来设置默认值。</li><li>默认值只能是编译时常量，所以当默认值是列表、字典、集合时，需要在其之前加上<code>const</code>，例如：<code>void doStuff({List&lt;int&gt; list = const [1, 2, 3]})</code></li></ul><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>所有的函数都返回一个值。如果没有指定返回值，则 默认把语句 return null; 作为函数的最后一个语句执行。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>大部分方法都带有名字，例如 main() 或者 printElement()。 你有可以创建没有名字的方法，称之为 匿名方法，有时候也被称为 lambda 或者 closure 闭包。</p><p>匿名函数的定义和函数的定义基本一致，只是没有函数名称而已：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">([[Type] param1[, …]]) &#123; </span><br><span class="line">  codeBlock; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>那么我们如何使用匿名函数呢？通过下面的例子我们简单理解下：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt; list = [<span class="string">'apples'</span>, <span class="string">'oranges'</span>, <span class="string">'grapes'</span>, <span class="string">'bananas'</span>, <span class="string">'plums'</span>];</span><br><span class="line">list.forEach((i) &#123;</span><br><span class="line">  <span class="built_in">print</span>(list.indexOf(i).toString() + <span class="string">': '</span> + i);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在使用<code>forEach</code>方法时，我们传入了一个闭包。</p><h2 id="函数当做对象使用"><a href="#函数当做对象使用" class="headerlink" title="函数当做对象使用"></a>函数当做对象使用</h2><p>可以把函数当做参数调用另外一个方法。例如：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">printElement(element) &#123;</span><br><span class="line">  <span class="built_in">print</span>(element);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">list.forEach(printElement);</span><br></pre></td></tr></table></figure><p>函数也可以赋值给一个变量：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> loudify = (msg) =&gt; <span class="string">'!!! <span class="subst">$&#123;msg.toUpperCase()&#125;</span> !!!'</span>;</span><br><span class="line"><span class="keyword">assert</span>(loudify(<span class="string">'hello'</span>) == <span class="string">'!!! HELLO !!!'</span>);</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过上面的学习我们了解到下面几点：</p><ol><li>在 Dart 中，函数是一个<code>Function</code>对象（很重要）；</li><li>函数包括返回值类型、函数名、参数列表和函数体；</li><li>函数参数分为必需和可选两大类，可选参数包含了命名参数和位置参数，并且命名参数和位置参数不能同时存在；</li><li>函数默认返回值为null；</li><li>匿名函数是一种没有函数名称的特殊函数，我们也称之为闭包；</li><li>由于函数的本质是对象，所以函数可以赋值给变量，当做参数和返回值使用。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dart 基础</title>
      <link href="/2019/08/20/Dart%E5%9F%BA%E7%A1%80/"/>
      <url>/2019/08/20/Dart%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<p>Dart语言是由谷歌公司开发的网络编程语言，于2011年10月10日发布。我们学习 Dart 语言，可以使我们更好的使用 Flutter 开发移动应用。废话不多说，我们直接来学习下吧。</p><h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World!"></a>Hello World!</h2><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">'Hello world!'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述代码，我们知道这里定义一个<code>main()</code>函数；在<code>main()</code>函数里面，我们打印了<code>Hello world！</code>字段。</p><a id="more"></a><h2 id="重要的概念"><a href="#重要的概念" class="headerlink" title="重要的概念"></a>重要的概念</h2><p>在我们了解Dart语言前，请记住以下事实和概念：</p><ul><li>我们放在变量中的所有内容都是一个对象，所有对象都继承自 <code>Object</code> 类；</li><li>尽管Dart是强类型的，但类型注释是可选的，因为Dart可以推断类型。例如将 <code>number</code> 推断为类型 <code>int</code>。如果要明确说明不需要任何类型，请使用特殊类型<code>dynamic</code>；</li><li>Dart支持泛型类型，如 <code>List&lt;int&gt;</code>（整数列表）或 <code>List&lt;dynamic&gt;</code>（任何类型的对象列表）;</li><li>Dart支持顶级函数（例如<code>main()</code>），以及绑定到类或对象的函数（分别是静态和实例方法）。您还可以在函数内创建函数（嵌套函数或本地函数）；</li><li>类似地，Dart支持顶级变量，以及绑定到类或对象的变量（静态和实例变量）。实例变量有时称为字段或属性；</li><li>与Java，飞镖不具备关键字public，protected和private。如果标识符以下划线（_）开头，则它对其库是私有的；</li><li>Dart工具可以报告两种问题：警告和错误。警告只是表明您的代码可能无法正常工作，但它们不会阻止您的程序执行。错误可以是编译时或运行时。编译时错误会阻止代码执行; 运行时错误导致 代码执行时引发异常。</li></ul><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>在 Dart 中，我们是如何创建和初始化变量的呢？</p><ol><li>使用关键字 var</li><li>使用关键字 dynamic</li><li>使用类型</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'Bob'</span>;</span><br><span class="line"><span class="keyword">dynamic</span> name = <span class="string">'Bob'</span>;</span><br><span class="line"><span class="built_in">String</span> name = <span class="string">'Bob'</span>;</span><br></pre></td></tr></table></figure><p>三者的区别在于：</p><ul><li>使用类型创建变量使用我手动确定变量的类型，而<code>var</code>和<code>dynamic</code>能够自动推断变量的类型；</li><li><code>var</code>和<code>dynamic</code>能够自动推断变量的类型；区别在于使用<code>var</code>声明的变量在编译时会自动推断出实际类型，并用实际类型来替换该变量的申明，所以只能引用相同类型的变量，而<code>dynamic</code>在编译时会变成一个<code>object</code>类型的对象，因此它在编译期间不进行任何的类型检查，而是将类型检查放到了运行期，所以可以引用不同类型的变量。</li></ul><h3 id="final-和-const"><a href="#final-和-const" class="headerlink" title="final 和 const"></a>final 和 const</h3><p>在 Dart 中，我们可以使用<code>final</code>和<code>const</code>来定义变量。如果我们使用<code>final</code>或者<code>const</code>来声明变量，那么变量只能被赋值一次，在变量的整个生命周期中，不会再发生任何改变。</p><p><strong>注意</strong>： 实例变量可以是<code>final</code>但不是<code>const</code>。<code>final</code>修饰的实例变量必须在构造函数中或者之前初始化。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> name = <span class="string">'Bob'</span>; <span class="comment">// 没有类型注释final String nickname = 'Bobby' ;  </span></span><br><span class="line"><span class="keyword">const</span> bar = <span class="number">1000</span>;</span><br><span class="line"><span class="keyword">const</span> baz = [];</span><br></pre></td></tr></table></figure><p><code>final</code>和<code>const</code>区别在于：</p><ul><li><code>final</code>可以修饰实例变量，而<code>const</code>不行；</li><li><code>final</code>是运行时特征，而<code>const</code>是编译时特征。</li></ul><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><ul><li>数字</li><li>字符串</li><li>布尔值</li><li>列表</li><li>集合</li><li>字典</li><li>Runes</li><li>Symbol</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> a       = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">double</span> b    = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="built_in">String</span> s    = <span class="string">"Hello wordl!"</span>;</span><br><span class="line"><span class="built_in">bool</span> isTrue = <span class="keyword">false</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">int</span>&gt; nums      = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">Set</span>&lt;<span class="built_in">String</span>&gt; sets    = &#123;<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>&#125;;</span><br><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, <span class="keyword">dynamic</span>&gt; maps = &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"Bob"</span>,</span><br><span class="line">    <span class="string">"age"</span>: <span class="number">27</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术操作符：+、-、*、/、~/、%</li><li>比较运算符：==、!=、&gt;=、&lt;=、&lt;、&gt;</li><li>类型判断：as、is、is!</li><li>赋值操作符: =、+=、-=、*=、/=、~/=、%=、|=、^=、&amp;=、&gt;&gt;=、&lt;&lt;=</li><li>逻辑运算符: !、||、&amp;&amp;</li><li>位运算符: &amp;、|、^、~、&gt;&gt;、&lt;&lt;</li><li>条件运算符: <code>condition ? expr1 : expr2</code>、<code>expr1 ?? expr2</code></li><li>级联操作符: …</li></ul><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><ul><li>if and else</li><li>for loops</li><li>while and do-while loops</li><li>break and continue</li><li>switch and case</li><li>assert</li></ul>]]></content>
      
      
      <categories>
          
          <category> Dart </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Objective-C 中 Category 真相</title>
      <link href="/2019/08/13/Objective-C%E4%B8%ADCategory%E7%9C%9F%E7%9B%B8/"/>
      <url>/2019/08/13/Objective-C%E4%B8%ADCategory%E7%9C%9F%E7%9B%B8/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在实际开发过程中，随着 App 版本的迭代，我的业务逻辑越来越复杂；原先我们设计和开发的类不能满足日常功能，需要添加新的功能。因此，我们需要对原有的类进行扩展。一般来说，继承和组合都是不错的选择；但在 Objective-C 2.0 中，又为我们提供了 Category 这一语言特征，让我们可以动态的为已存在的类添加新行为。那么，今天我们就来详细的了解下 Category 的使用和原理。</p><ul><li>什么是 Category，如何创建？</li><li>Category 和 Extension 的区别</li><li>Category 真正的面目</li><li>Category 是如何为已有类添加新功能的</li><li>Category 和 +(void)load 方法的关系</li><li>Category 和方法覆盖</li><li>Category 和关联对象</li></ul><a id="more"></a><h2 id="什么是分类（Category）"><a href="#什么是分类（Category）" class="headerlink" title="什么是分类（Category）"></a>什么是分类（Category）</h2><p>Category 是 Objective-C 2.0之后添加的语言特性，主要作用是为已有的类添加新方法。除此之外，Apple 还推荐了 Category 的另外两个使用场景：</p><ul><li><p>为类瘦身，把类的实现分别写在不同的文件中；</p><ol><li>减少单个文件的体积</li><li>可以把相同功能代码整合到同一个分类中</li><li>多人通过分类共同完成一个类，将降低耦合度</li><li>可以按需加载想要的 category</li></ol></li><li><p>声明私有方法。</p></li></ul><p>不过除了 Apple 推荐的使用场景，广大开发者脑洞大开，还衍生出了 Category 的其他几个使用场景：</p><ul><li>模拟多继承</li><li>把 Framework 的私有方法公开</li></ul><h3 id="如何给已有的类添加一个分类"><a href="#如何给已有的类添加一个分类" class="headerlink" title="如何给已有的类添加一个分类"></a>如何给已有的类添加一个分类</h3><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">ClassName</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)lastNameFirstNameString;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">ClassName</span> (<span class="title">CategoryName</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)lastNameFirstNameString &#123;</span><br><span class="line">    <span class="keyword">return</span> [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@, %@"</span>, <span class="keyword">self</span>.lastName, <span class="keyword">self</span>.firstName];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><h2 id="Category-和-Extension-的区别"><a href="#Category-和-Extension-的区别" class="headerlink" title="Category 和 Extension 的区别"></a>Category 和 Extension 的区别</h2><p>Extension 看起来很像一个匿名的 Category，但是 Extension和有名字的 Category 几乎完全是两个东西。下面我来分析下二者之间的区别：</p><p>Extension 编译期特征；在编译的过程中，与头文件中 @interface 和实现文件中 @implementation 一起组成了完整的类。Extension 会随着类的生成而生成，消亡而消亡。一般来说，我们通常使用 Extension 来隐藏私有的属性和方法；但是我们永远无法给系统的类添加 Extension。</p><p>Category 运行时特征；因此我们无法使用 Category 为已有类添加实例变量。（因为在运行期，对象的内存布局已经确定，如果添加实例变量就会破坏类的内部布局，这对编译型语言来说是灾难性的）。</p><h2 id="Category-真正的面目"><a href="#Category-真正的面目" class="headerlink" title="Category 真正的面目"></a>Category 真正的面目</h2><p>通过上述说明，我们知道了 Category 是运行时特性；所以，我看来运行时我们写的分类最终到底变成了什么？下面我们编写一个分类，并使用 clang 的命令去看看 Category 到底会变成什么？</p><p>首先，我先编写了 Person 类，并为 Person 类添加了 Addition 分类；在分类中具有属性 name 和方法 - (void)printName。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Person</span> (<span class="title">Addition</span>)</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span> ) <span class="built_in">NSString</span> *name;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)loadNew;</span><br><span class="line">- (<span class="keyword">void</span>)printName;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.m</span></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">Person</span> (<span class="title">Addition</span>)</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setName:(<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)name &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">@"name"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)loadNew &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)printName &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, <span class="string">@"Addition"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure><p>之后，我使用<code>clang++ -rewrite-objc Person.m</code>将对代码进行了编译，等到了 cpp 文件；在 cpp 文件中我找到了下面几段代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[3];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Addition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">    <span class="number">3</span>,</span><br><span class="line">    &#123;&#123;(struct objc_selector *)<span class="string">"setName:"</span>, <span class="string">"v24@0:8@16"</span>, (<span class="keyword">void</span> *)_I_Person_Addition_setName_&#125;,</span><br><span class="line">    &#123;(struct objc_selector *)<span class="string">"name"</span>, <span class="string">"@16@0:8"</span>, (<span class="keyword">void</span> *)_I_Person_Addition_name&#125;,</span><br><span class="line">    &#123;(struct objc_selector *)<span class="string">"printName"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_I_Person_Addition_printName&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Addition</code>这个名称，我们很自然的知道了这里就是我们分类实例方法存放的位置。下面我们继续往下看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">method_list_t</span>*/ &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _objc_method)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> method_count;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">objc_method</span> <span class="title">method_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Addition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(_objc_method),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;(struct objc_selector *)<span class="string">"loadNew"</span>, <span class="string">"v16@0:8"</span>, (<span class="keyword">void</span> *)_C_Person_Addition_loadNew&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Addition</code>这个名称，我们也很自然的知道了这里就是我们分类类方法存放的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> /*_<span class="title">prop_list_t</span>*/ &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> entsize;  <span class="comment">// sizeof(struct _prop_t)</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> count_of_properties;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> _<span class="title">prop_t</span> <span class="title">prop_list</span>[1];</span></span><br><span class="line">&#125; _OBJC_$_PROP_LIST_Person_$_Addition __attribute__ ((used, section (<span class="string">"__DATA,__objc_const"</span>))) = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(<span class="keyword">_prop_t</span>),</span><br><span class="line">    <span class="number">1</span>,</span><br><span class="line">    &#123;&#123;<span class="string">"name"</span>,<span class="string">"T@\"NSString\",C,N"</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过 <code>_OBJC_$_PROP_LIST_Person_$_Addition</code>这个名称，我们也很自然的知道了这里就是我们分类属性方法存放的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> _<span class="title">category_t</span> _<span class="title">OBJC_</span>$_<span class="title">CATEGORY_Person_</span>$_<span class="title">Addition</span> __<span class="title">attribute__</span> ((<span class="title">used</span>, <span class="title">section</span> ("__<span class="title">DATA</span>,__<span class="title">objc_const</span>"))) = &#123;</span></span><br><span class="line">    <span class="string">"Person"</span>,</span><br><span class="line">    <span class="number">0</span>, <span class="comment">// &amp;OBJC_CLASS_$_Person,</span></span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_INSTANCE_METHODS_Person_$_Addition,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_method_list_t</span> *)&amp;_OBJC_$_CATEGORY_CLASS_METHODS_Person_$_Addition,</span><br><span class="line">    <span class="number">0</span>,</span><br><span class="line">    (<span class="keyword">const</span> struct <span class="keyword">_prop_list_t</span> *)&amp;_OBJC_$_PROP_LIST_Person_$_Addition,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> OBJC_CATEGORY_SETUP_$_Person_$_Addition(<span class="keyword">void</span> ) &#123;</span><br><span class="line">    _OBJC_$_CATEGORY_Person_$_Addition.cls = &amp;OBJC_CLASS_$_Person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这个，我们就应该忽然明白了我们的分类是如何创建的。这里创建了我们需要的分类并将实例方法列表、类方法列表、属性列表等绑定到了分类上；同时，也将分类和类进行了绑定。通过上述代码，我们知道了分类最终就是<code>category_t</code>结构体。下面我们来看看这个结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">category_t</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">    <span class="keyword">classref_t</span> cls;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">instanceMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">method_list_t</span> *<span class="title">classMethods</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">protocol_list_t</span> *<span class="title">protocols</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">property_list_t</span> *<span class="title">instanceProperties</span>;</span></span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure><ul><li>1)、类的名字（name）</li><li>2)、类（cls）</li><li>3)、category中所有给类添加的实例方法的列表（instanceMethods）</li><li>4)、category中所有添加的类方法的列表（classMethods）</li><li>5)、category实现的所有协议的列表（protocols）</li><li>6)、category中添加的所有属性（instanceProperties）</li></ul><h2 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h2>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 内存管理机制</title>
      <link href="/2019/08/07/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/"/>
      <url>/2019/08/07/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>看过 iOS 书籍和开发过苹果App的小伙伴们，都会去了解和学习 iOS的内存管理机制。那么今天我们就一起梳理下 Objective-C 中的内存管理机制。首先我们先看下下图，了解下我们从哪些方面学习！</p><p><img src="/images/iOS%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%E7%9F%A5%E8%AF%86%E7%82%B9.png" alt="iOS内存管理机制知识点"></p><a id="more"></a><h2 id="什么是内存管理"><a href="#什么是内存管理" class="headerlink" title="什么是内存管理"></a>什么是内存管理</h2><p>内存是我们运行程序锁必须的资源，但是内存是有限的，我们不能无休止的使用它；因此，我们需要对内存进行管理。在 iOS 中，我们通常将内存分为五大部分：</p><ul><li>代码区</li><li>全局区/静态区</li><li>文字常量区</li><li>栈（Stack）</li><li>堆（Heap）</li></ul><p>上面五大部分中，只有堆的内存是需要程序员手动管理的。所有今天我们学习的内存管理，管理的就是堆这部分的内存。</p><h2 id="iOS-是如何管理内存"><a href="#iOS-是如何管理内存" class="headerlink" title="iOS 是如何管理内存"></a>iOS 是如何管理内存</h2><p>在 iOS 中，提供了 MRC（手动引用计数）和 ARC（自动引用计数）两种方式来进行内存管理的。而无论是哪种方式，它们的核心机制都是对引用计数的管理。那么是引用计数呢？下面我们简单描述下：</p><h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>引用计数，说白了就是个数字。它的作用就是用来记录对象被引用了几次。如果说被引用了1次，那么引用计数就是1；如果说被引用了3次，那么引用计数就是3。那在 Objective-C 内存管理中，系统会去判断引用计数是否为0；若为0，就表示该对象没有被引用，那么系统就是自动释放它的内存；反之，若不为0，则该对象的内存不会被释放。</p><h2 id="我们如何进行内存管理-——-MRC"><a href="#我们如何进行内存管理-——-MRC" class="headerlink" title="我们如何进行内存管理 —— MRC"></a>我们如何进行内存管理 —— MRC</h2><p>顾名思义，MRC就是调用 Objective-C 的方法（alloc/new/copy/mutableCopy/retain/release等）实现引用计数的增加和减少。规则如下：</p><table><thead><tr><th>对象操作</th><th align="center">Objective-C 方法</th></tr></thead><tbody><tr><td>生成并持有对象</td><td align="center">alloc/new/copy/mutableCopy 等方法</td></tr><tr><td>持有对象</td><td align="center">retain  方法</td></tr><tr><td>释放对象</td><td align="center">release 方法</td></tr><tr><td>销毁对象</td><td align="center">dealloc 方法</td></tr></tbody></table><p>对于引用计数的管理，我们可以理解为下面4个原则：</p><ol><li>自己生成的对象，自己所持有；</li><li>非自己生成的对象，自己也可能持有；</li><li>不再需要自己持有的对象时释放；</li><li>非自己持有的对象无法释放。</li></ol><h3 id="自己生成的对象，自己持有"><a href="#自己生成的对象，自己持有" class="headerlink" title="自己生成的对象，自己持有"></a>自己生成的对象，自己持有</h3><p>使用以下名称开头的方法意味着自己生成的对象，自己持有。</p><ul><li>alloc</li><li>new</li><li>copy</li><li>mutableCopy</li></ul><p>现在，我们可以看下面的代码：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj1 = [[<span class="built_in">NSArray</span> alloc] init];   <span class="comment">// 生成并持有对象</span></span><br><span class="line"><span class="keyword">id</span> obj2 = [<span class="built_in">NSArray</span> array];          <span class="comment">// 生成对象并未持有</span></span><br></pre></td></tr></table></figure><p>obj1 是通过 alloc 创建的所以对象自己是持有的；而 obj2 是通过类方法创建，对象本身是不持有的。这意味着 obj2 在后面的时候用过程中可能会出错。（原因是 array 方法内，使用了 autorelease 延迟了对象的销毁）</p><h3 id="非自己生成的对象，自己也能持有"><a href="#非自己生成的对象，自己也能持有" class="headerlink" title="非自己生成的对象，自己也能持有"></a>非自己生成的对象，自己也能持有</h3><p>当我们使用非 alloc、new、copy、mutableCopy 方法来生成对象时，我们可以使用 retain 来持有对象。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSArray</span> array];   <span class="comment">// 生成对象并未持有</span></span><br><span class="line">[obj <span class="keyword">retain</span>];               <span class="comment">// 持有对象</span></span><br></pre></td></tr></table></figure><h3 id="不需要自己持有对象时释放"><a href="#不需要自己持有对象时释放" class="headerlink" title="不需要自己持有对象时释放"></a>不需要自己持有对象时释放</h3><p>自己持有对象，一旦自己不要了，可以直接使用 release/autorelease 释放对象</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[obj release];      <span class="comment">// 引用计数减1。</span></span><br><span class="line">[obj autorelease];  <span class="comment">// 在auto release pool释放的时候，引用计数减1。</span></span><br></pre></td></tr></table></figure><p>这里我们需要注意 autorelease 不会立即释放对象，而是在auto release pool释放的时候，统一释放自动释放池中所有需要释放的对象。</p><p><img src="/images/release%E5%92%8Cautorelease%E7%9A%84%E5%8C%BA%E5%88%AB.png" alt="release和autorelease的区别"></p><h3 id="无法释放非自己持有的对象"><a href="#无法释放非自己持有的对象" class="headerlink" title="无法释放非自己持有的对象"></a>无法释放非自己持有的对象</h3><p>不是自己所持有的对象，我们是无法使用 release/autorelease 释放的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [<span class="built_in">NSObject</span> new];    <span class="comment">// obj是持有对象的</span></span><br><span class="line">[obj release];              <span class="comment">// obj释放对象，不持有对象</span></span><br><span class="line">[obj release];              <span class="comment">// obj再次释放对象，这是会报错。</span></span><br></pre></td></tr></table></figure><h2 id="更加智能的内存管理-——-ARC"><a href="#更加智能的内存管理-——-ARC" class="headerlink" title="更加智能的内存管理 —— ARC"></a>更加智能的内存管理 —— ARC</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>顾名思义，自动引用计数是指内存管理中对引用采用自动计数的技术。在 Objective-C 中采用 ARC 机制，让编译器来进行内存管理，无需再次键入retain和release代码。</p><p>好处：</p><ul><li>降低了程序奔溃、内存泄漏等风险；</li><li>减少了开发程序的工作量；</li><li>能够立即释放那些不再被使用的对象，提供了程序的整体性能。</li></ul><h3 id="所有权修饰符"><a href="#所有权修饰符" class="headerlink" title="所有权修饰符"></a>所有权修饰符</h3><p>ARC 下，id类型和对象类型同C语言的其他类型不同，其类型上必须附加所有权修饰符。所有权修饰符一共有4个，如下：</p><ul><li>__strong 修饰符</li><li>__weak 修饰符</li><li>__unsafe_unretained 修饰符</li><li>__autoreleasing 修饰符</li></ul><p>__strong修饰符是id类型和对象类型默认的所有权修饰符。也就是说下面的源码中，id变量实际上被附加了所有权修饰符：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><p>id和对象类型在没有明确指定所有权修饰符时，默认为 __strong 修饰符。上述源码与下面源码是相同的。</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">id</span> __<span class="keyword">strong</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br></pre></td></tr></table></figure><p>__weak修饰符不能持有对象实例，通常用来解决引用计数的循环引用问题；并且当引用的对象销毁时，弱引用将自动失效且处于nil被赋值状态。</p><p>__unsafe_unretained 修饰符表示其修饰的变量不属于编译器的内存管理对象；附有 __unsafe_unretained 修饰符的变量同附有 __weak 修饰符的变量一样，都不会持有对象。</p><p>__autoreleasing修饰符用来修饰自动释放池中创建的对象。</p><p>在 MRC 中，我们是这样使用自动释放池的，源码如下：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSAutoreleasePool</span> *pool = [[<span class="built_in">NSAutoreleasePool</span> alloc] init];</span><br><span class="line"><span class="keyword">id</span> obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">[obj autorelease];</span><br><span class="line">[pool drain];</span><br></pre></td></tr></table></figure><p>而在 ARC 中，我们的代码是这样子的：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@autoreleasepool</span> &#123;</span><br><span class="line">    <span class="keyword">id</span> __autoreleasing obj = [[<span class="built_in">NSObject</span> alloc] init];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ARC-规则"><a href="#ARC-规则" class="headerlink" title="ARC 规则"></a>ARC 规则</h3><ul><li>不能使用 retain/release/retainCount/autorelease</li><li>不能使用 NSAllocateObject/NSDeallocateObject</li><li>须遵守内存管理的方法命名规则</li><li>不需要显式调用 dealloc</li><li>使用@autorelease来代替NSAutoreleasePool</li><li>不能使用区域（NSZone）</li><li>对象类型变量不能作为C语言结构体（struct/union）的成员</li><li>显式转换”id”和”Void *”</li></ul><h2 id="Toll-Free-Bridging（免费桥）"><a href="#Toll-Free-Bridging（免费桥）" class="headerlink" title="Toll-Free Bridging（免费桥）"></a>Toll-Free Bridging（免费桥）</h2><p>Toll-Free Bridging, 简称为TFB，是一种允许某些 ObjC 类与其对应的 CoreFoundation 类之间可以互换使用的机制。比如 NSString 与 CFString 是桥接(bridge)的, 这意味着可以将任意    NSString 当做 CFString 使用，也可以将任意的 CFString 当做 NSString 使用。</p><p>转换的方式：</p><ul><li>__bridge：可以实现Objective-C对象和Core Foundation对象的相互转换，而且不会进行所有权的转换。</li><li>__bridge_retained 或 CFBridgingRetain：只能将 Objective-C 对象转换为 Core Foundation 对象，同时将所有权交给CF对象；</li><li>__bridge_transfer 或 CFBridgingRelease：只能将非 Objective-C 对象转换为 Objective-C 对象，同时将所有权交给ARC。</li></ul><p>在我们使用 Toll-Free Bridging 转换对象所有权时，也就意味着对象的内存管理机制发生了变化。Foundation 框架下，对象的内存管理是由系统自动管理的（ARC），而在 Core Foundation 框架下，系统的内存管理，需要程序员自己管理。</p><h2 id="常见的内存管理问题"><a href="#常见的内存管理问题" class="headerlink" title="常见的内存管理问题"></a>常见的内存管理问题</h2><ul><li>循环引用</li><li>NSTimer 释放不当</li><li>桥接导致所有权变化，而产生的内存管理问题</li><li>使用循环产生大量局部变量，导致内存警告问题</li></ul><h2 id="如何检查内存泄漏问题"><a href="#如何检查内存泄漏问题" class="headerlink" title="如何检查内存泄漏问题"></a>如何检查内存泄漏问题</h2><ul><li>僵尸对象图</li><li>Leaks</li></ul>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>iOS 事件的响应与分发</title>
      <link href="/2019/08/05/iOS%20%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E4%B8%8E%E5%88%86%E5%8F%91/"/>
      <url>/2019/08/05/iOS%20%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%93%8D%E5%BA%94%E4%B8%8E%E5%88%86%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>在移动端中，用户与App的交流大多都是通过用户的点击来进行的。所以，学习事件的响应过程和分发机制是分成有必要的。下面我们会从三个方面进行学习：</p><ul><li>基础概念和知识点</li><li>事件是如何进行分发的？</li><li>事件最终是如何进行响应的？</li></ul><a id="more"></a><h2 id="iOS-事件的响应与分发"><a href="#iOS-事件的响应与分发" class="headerlink" title="iOS 事件的响应与分发"></a>iOS 事件的响应与分发</h2><h3 id="基础概念和知识点"><a href="#基础概念和知识点" class="headerlink" title="基础概念和知识点"></a>基础概念和知识点</h3><p>首页，我们来介绍下iOS的事件、与事件相关的类、与事件相关的Api。在 iOS 中，事件被分成三大类：</p><ol><li>触屏事件</li><li>传感事件</li><li>远程遥控事件</li></ol><p>这里我们主要学习讨论触屏事件（即我们经常使用的点击、拖拽、缩放、移动等事件）。</p><h4 id="UIResponder（响应者对象）"><a href="#UIResponder（响应者对象）" class="headerlink" title="UIResponder（响应者对象）"></a>UIResponder（响应者对象）</h4><p>在 iOS 中并不是所有的对象都可以接收处理事件的，只用继承于 UIResponder 的类的实例对象才可以接收处理事件。这些可以处理事件的对象，我们称之为”响应者对象”。<br>在 iOS 中继承于 UIResponder 的类有：</p><ul><li>UIApplication</li><li>UIView</li><li>UIControl</li></ul><p>那么 UIResponder 又是如何接收处理响应事件的呢？通过查看Api，我们可以看到以下方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// UIResponder内部提供了以下方法来处理事件触摸事件</span></span><br><span class="line">- (<span class="keyword">void</span>)touchesBegan:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesMoved:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesEnded:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)touchesCancelled:(<span class="built_in">NSSet</span> *)touches withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加速计事件</span></span><br><span class="line">- (<span class="keyword">void</span>)motionBegan:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionEnded:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line">- (<span class="keyword">void</span>)motionCancelled:(<span class="built_in">UIEventSubtype</span>)motion withEvent:(<span class="built_in">UIEvent</span> *)event;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 远程控制事件</span></span><br><span class="line">- (<span class="keyword">void</span>)remoteControlReceivedWithEvent:(<span class="built_in">UIEvent</span> *)event;</span><br></pre></td></tr></table></figure><p>通过重写这些方法，我们可以在处理触摸开始、移动、结束、取消等状态下的响应。</p><h4 id="UITouch"><a href="#UITouch" class="headerlink" title="UITouch"></a>UITouch</h4><p>用来保存着跟手指相关的信息，比如触摸的位置、时间、阶段。当用户手指触摸屏幕时，会自动创建；用户手指移动时，会更新；当用户手指离开屏幕时，会销毁。</p><h5 id="UITouch-属性"><a href="#UITouch-属性" class="headerlink" title="UITouch 属性"></a>UITouch 属性</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录了触摸事件产生或变化时的时间，单位是秒</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSTimeInterval</span>      timestamp;</span><br><span class="line"><span class="comment">// 当前触摸事件所处的状态</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">UITouchPhase</span>        phase;</span><br><span class="line"><span class="comment">// 短时间内点按屏幕的次数，可以根据tapCount判断单击、双击或更多的点击</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>) <span class="built_in">NSUInteger</span>          tapCount;</span><br><span class="line"><span class="comment">// 触摸产生时所处的窗口</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIWindow</span>                        *window;</span><br><span class="line"><span class="comment">// 触摸产生时所处的视图</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nullable</span>,<span class="keyword">nonatomic</span>,<span class="keyword">readonly</span>,<span class="keyword">strong</span>) <span class="built_in">UIView</span>                          *view;</span><br></pre></td></tr></table></figure><h5 id="UITouch-方法"><a href="#UITouch-方法" class="headerlink" title="UITouch 方法"></a>UITouch 方法</h5><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回值表示触摸在view上的位置</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)locationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;</span><br><span class="line"><span class="comment">// 该方法记录了前一个触摸点的位置</span></span><br><span class="line">- (<span class="built_in">CGPoint</span>)previousLocationInView:(<span class="keyword">nullable</span> <span class="built_in">UIView</span> *)view;</span><br></pre></td></tr></table></figure><h3 id="事件是如何进行分发的"><a href="#事件是如何进行分发的" class="headerlink" title="事件是如何进行分发的"></a>事件是如何进行分发的</h3><ol><li>发生触摸事件后，系统会自动创建一个事件；并将事件加入到 UIApplication 事件管理队列中。</li><li>UIApplication 取出事件管理队列中最前面的事件，将取出的事件传给 keyWindow。</li><li>keyWindow 判断自己是否可以接受处理事件；如果可以，则遍历其所有子试图将事件传递给子试图。</li><li>子试图执行和 keyWindow 同样的操作，一直到找到最适合响应事件的响应者对象。</li><li>使用最终找到的响应者对象处理响应事件。</li></ol><p>通过上面的步骤我们知道了事件是如何一层层的分发传递的，最终找到最适合的响应者对象。那么，上面的 keyWindow 和子试图是如何判断自己是否可以接受处理事件的呢？</p><p>keyWindow 会调用该视图的<code>-(UIView *)hitTest CGPoint(point) withEvent:(UIEvent *)event</code>方法；在该方法中会执行以下操作：</p><ol><li>判断 userInteractionEnabled 是否为NO，hidden 是否为YES，alpha 是否小与0.01，这三个条件只要有一个满足，则直接返回nil；否则，执行下一步；</li><li>调用 <code>-(BOOL)pointInSide CGPoint(point) wihtEvent(UIEvent *):event</code>方法判断触摸点是否在试图之内；如何为否，则直接返回nil；否则，执行下一步；</li><li>遍历子试图，并调用子试图的<code>-(UIView *)hitTest CGPoint(point) withEvent:(UIEvent *)event</code>方法；如果遍历完成后，找到<code>fitView</code>，则返回<code>fitView</code>；否则直接返回self本身。</li></ol><h3 id="事件最终是如何进行响应的"><a href="#事件最终是如何进行响应的" class="headerlink" title="事件最终是如何进行响应的"></a>事件最终是如何进行响应的</h3><ol><li>获取最适合的响应者对象后，判断是否处理响应事件（即实现 touchBegan、touchMoved、touchEnded、touchCancelled等方法）；若处理了，则直接结束响应事件；若没有，则传递给上一个响应者；</li><li>上一个响应者接收到响应事件后，继续执行步骤1相同的操作，直至传递给 UIApplication；</li><li>UIApplication 接收到响应时间后，同样判断是否处理响应事件；若还是没有处理，则直接忽略该响应事件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> iOS </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
